# Splitstree Phylogenetic Network

This page describes how the Splitstree network was generated. The input data for this analysis is the VCF file `Ceratopipra_rubrocapilla_imeriout_m07.GBSPipfilbwa.allsites.filtered.genicintergenic.forSVD.49_0.2_5_20`.  

In our dataset, we have:  

* 68 taxa  
* 82,218 bp  

## Generate input file
First, we need to generate an input file in nexus format for Splitstree.  
```bash
#this analysis was set up in the same directory as SVDQuartets, since the method of making the nex file is the same as for that analysis.  
cd /home/1_Else/Ceratopipra/2_Phylogeny/2.1aa_SVDquartets

#get data here
cp /home/1_Else/Ceratopipra/1_Datasets/1.3a_genotyping/filteredSNPs/Ceratopipra_rubrocapilla_imeriout_m07.GBSPipfilbwa.allsites.filtered.genicintergenic.forSVD.49_0.2_5_20 ./data
gunzip data/Ceratopipra_rubrocapilla_imeriout_m07.GBSPipfilbwa.allsites.filtered.genicintergenic.forSVD.49_0.2_5_20.vcf.gz ; time ruby /home/0_PROGRAMS/mmatschiner/convert_vcf_to_nexus.rb data/Ceratopipra_rubrocapilla_imeriout_m07.GBSPipfilbwa.allsites.filtered.genicintergenic.forSVD.49_0.2_5_20.vcf data/Ceratopipra_rubrocapilla_imeriout_m07.GBSPipfilbwa.allsites.filtered.genicintergenic.forSVD.49_0.2_5_20.nex
#now we have a nexus file.

#add location tag to sample names to make it easier for me to colour branches by population
#convert N's to gaps so that they are not incorporated as ambiguous sites in the distance matrix calculation
parallel 'head -n 8 data/{1}.nex > data/{1}.renamed.gapped.nex ; tail -n +9 data/{1}.nex | head -n -2 | sed "s/Ceratopipra_rubrocapilla_CPE012/M_CPE012_AF.Ib/g; s/Ceratopipra_rubrocapilla_CPE025/M_CPE025_AF.Ib/g; s/Ceratopipra_rubrocapilla_CPE069/M_CPE069_AF.Ib/g; s/Ceratopipra_rubrocapilla_CPEII008/M_CPEII008_AF.Ib/g; s/Ceratopipra_rubrocapilla_UNA018/M_UNA018_AF.Il/g; s/Ceratopipra_rubrocapilla_UNA088/M_UNA088_AF.Il/g; s/Ceratopipra_rubrocapilla_UNA110/M_UNA110_AF.Il/g; s/Ceratopipra_rubrocapilla_UNA124/M_UNA124_AF.Il/g; s/Ceratopipra_rubrocapilla_MT123/M_MT123_hw/g; s/Ceratopipra_rubrocapilla_OM112/M_OM112_IE/g; s/Ceratopipra_rubrocapilla_AMA340/M_AMA340_IW/g; s/Ceratopipra_rubrocapilla_AMA601/M_AMA601_IW/g; s/Ceratopipra_rubrocapilla_AMA656/M_AMA656_IW/g; s/Ceratopipra_rubrocapilla_B4615/M_B4615_IW/g; s/Ceratopipra_rubrocapilla_B5082/M_B5082_IW/g; s/Ceratopipra_rubrocapilla_CAM117/M_CAM117_IW/g; s/Ceratopipra_rubrocapilla_PUC007/M_PUC007_IW/g; s/Ceratopipra_rubrocapilla_PUC008/M_PUC008_IW/g; s/Ceratopipra_rubrocapilla_UFAC1007/M_UFAC1007_IW/g; s/Ceratopipra_erythrocephala_SGC288/M_Ceratopipra_erythrocephala_SGC288_O/g; s/Ceratopipra_erythrocephala_B7534/M_Ceratopipra_erythrocephala_B7534_O/g; s/Ceratopipra_erythrocephala_B7539/M_Ceratopipra_erythrocephala_B7539_O/g; s/Ceratopipra_erythrocephala_B7536/M_Ceratopipra_erythrocephala_B7536_O/g; s/Ceratopipra_erythrocephala_B7537/M_Ceratopipra_erythrocephala_B7537_O/g; s/Ceratopipra_rubrocapilla_FPR015/M_FPR015_R/g; s/Ceratopipra_rubrocapilla_FPR021/M_FPR021_R/g; s/Ceratopipra_rubrocapilla_MAM010/M_MAM010_R/g; s/Ceratopipra_rubrocapilla_MAR092/M_MAR092_R/g; s/Ceratopipra_rubrocapilla_PIME024/M_PIME024_R/g; s/Ceratopipra_rubrocapilla_PIME062/M_PIME062_R/g; s/Ceratopipra_rubrocapilla_PIME460/M_PIME460_R/g; s/Ceratopipra_rubrocapilla_BR036/M_BR036_T/g; s/Ceratopipra_rubrocapilla_MF005/M_MF005_T/g; s/Ceratopipra_rubrocapilla_PIME134/M_PIME134_T/g; s/Ceratopipra_rubrocapilla_TLP123/M_TLP123_T/g; s/Ceratopipra_rubrocapilla_PPS041/M_PPS041_Thw/g; s/Ceratopipra_rubrocapilla_PPS221/M_PPS221_Thw/g; s/Ceratopipra_rubrocapilla_GAPTO277/M_GAPTO277_X.C/g; s/Ceratopipra_rubrocapilla_UHE442/M_UHE442_X.N/g; s/Ceratopipra_rubrocapilla_CPE049/F_CPE049_AF.Ib/g; s/Ceratopipra_rubrocapilla_UNA002/F_UNA002_AF.Il/g; s/Ceratopipra_rubrocapilla_MT087/F_MT087_hw/g; s/Ceratopipra_rubrocapilla_OM022/F_OM022_IE/g; s/Ceratopipra_rubrocapilla_OM172/F_OM172_IE/g; s/Ceratopipra_rubrocapilla_UFAC305/F_UFAC305_IE/g; s/Ceratopipra_rubrocapilla_CUJ027/F_CUJ027_IW/g; s/Ceratopipra_rubrocapilla_CUJ072/F_CUJ072_IW/g; s/Ceratopipra_rubrocapilla_UFAC476/F_UFAC476_IW/g; s/Ceratopipra_rubrocapilla_FPR006/F_FPR006_R/g; s/Ceratopipra_rubrocapilla_MPDS628/F_MPDS628_R/g; s/Ceratopipra_rubrocapilla_PIME079/F_PIME079_R/g; s/Ceratopipra_rubrocapilla_PIME169/F_PIME169_R/g; s/Ceratopipra_rubrocapilla_AMZ551/F_AMZ551_Rhw/g; s/Ceratopipra_rubrocapilla_AMZ610/F_AMZ610_Rhw/g; s/Ceratopipra_rubrocapilla_OP100/F_OP100_Rhw/g; s/Ceratopipra_rubrocapilla_BR033/F_BR033_T/g; s/Ceratopipra_rubrocapilla_PIME135/F_PIME135_T/g; s/Ceratopipra_rubrocapilla_PIME482/F_PIME482_T/g; s/Ceratopipra_rubrocapilla_PIME522/F_PIME522_T/g; s/Ceratopipra_rubrocapilla_PPS174/F_PPS174_T/g; s/Ceratopipra_rubrocapilla_TLP025/F_TLP025_T/g; s/Ceratopipra_rubrocapilla_WM293/F_WM293_T/g; s/Ceratopipra_rubrocapilla_GAPTO259/F_GAPTO259_X.C/g; s/Ceratopipra_rubrocapilla_GAPTO268/F_GAPTO268_X.C/g; s/Ceratopipra_rubrocapilla_GAPTO327/F_GAPTO327_X.C/g; s/Ceratopipra_rubrocapilla_RDO007/F_RDO007_X.C/g; s/Ceratopipra_rubrocapilla_PPBIO221/F_PPBIO221_X.N/g; s/Ceratopipra_rubrocapilla_PPBIO305/F_PPBIO305_X.N/g; s/N/-/g" >> data/{1}.renamed.gapped.nex; tail -n 2 data/{1}.nex >> data/{1}.renamed.gapped.nex' ::: Ceratopipra_rubrocapilla_imeriout_m07.GBSPipfilbwa.allsites.filtered.genicintergenic.forSVD.49_0.2_5_20
```

# Run Splitstree
Once we have the nexus file, we can import it into Splitstree.  
I am using a graphical user interface. Here are my mouse clicks:  

First, open the file:  
`File -> Open -> select "Ceratopipra_rubrocapilla_imeriout_m07.GBSPipfilbwa.allsites.filtered.genicintergenic.forSVD.49_0.2_5_20.renamed.gapped.nex" -> Open`

There are many different distance metrics available. Each one may have slightly different results, but if the overall signal in the data is strong, most of them should give qualitatively similar results. Most importantly, we need a metric that will ignore gaps (not count them towards differences between samples) since they represent missing data in our dataset, and we need a metric that can handle ambiguity codes, since our heterozygous sites are represented with IUPAC ambiguity codes. For example, it seems that SplitsTree (at least in this version) does not count ambiguity codes towards the distance matrix with the Kimura 2-parameter distance metric, which is usually my go-to for estimating genetic distances. Instead I will use the Uncorrected P distance, which is a very simple measure and has options to incorporate ambiguity codes (it does not by default).  

Select the distance metric:  
`Distances -> UncorrectedP -> Handle ambiguous states: MatchStates -> Apply `

The program will then draw a phylogenetic network.  

SplitsTree automatically draws the network using the Equal Angle algorithm, and with the NeighbourNet algorithm. We will keep these defaults.  

I save the image to use as a figure:  
`File -> Export Image -> PDF -> Apply`  

I saved a copy of the input nexus file and the image of the figure into the folder `2.3aa_splitstree`.  



# Appendix
Here are the contents of `/home/0_PROGRAMS/mmatschiner/convert_vcf_to_nexus.rb`, a script by Michael Matschiner.

```ruby
# m_matschiner Thu May 10 12:20:01 CEST 2018

# Get the command-line arguments.
vcf_file_name = ARGV[0]
nexus_file_name = ARGV[1]

# Feedback.
puts
puts "Input vcf file: #{vcf_file_name}."
puts "Output nexus file: #{nexus_file_name}"
puts
STDOUT.flush

# Open the input vcf file.
print "Opening vcf file #{vcf_file_name}..."
STDOUT.flush
vcf_file = File.open(vcf_file_name)
puts " done."
STDOUT.flush

# Read each line of the input vcf file and add gts to sequences.
ids = []
seqs = []
ids_found = false
previous_lg = ""
vcf_file.each do |l|
	if l[0] == "#"
		if l[0..5] == "#CHROM"
			ids = l.split[9..-1]
			ids.each do |i|
				seqs << ""
			end
			ids_found = true
		end
	elsif ids_found and l.strip != ""
		line_ary = l.split
		lg = line_ary[0]
		if previous_lg == ""
			print "Reading #{lg}..."
			STDOUT.flush
		elsif lg != previous_lg
			puts " done."
			print "Reading #{lg}..."
			STDOUT.flush
		end
		previous_lg = lg
		ref = line_ary[3]
		alt = line_ary[4]
		alleles = [ref]
		alt.split(",").each do |a|
			alleles << a
		end
		ids.size.times do |x|
			gt = line_ary[9+x]
			if gt.match(/([\d\.])[\/\|]([\d\.])/)
				if $1 == "." and $2 == "."
					sample_allele1 = "N"
					sample_allele2 = "N"
				else
					sample_allele1 = alleles[$1.to_i]
					sample_allele2 = alleles[$2.to_i]
				end
				if sample_allele1 == "A" and sample_allele2 == "A"
					gt_iupac = "A"
				elsif sample_allele1 == "A" and sample_allele2 == "C"
					gt_iupac = "M"
				elsif sample_allele1 == "A" and sample_allele2 == "G"
					gt_iupac = "R"
				elsif sample_allele1 == "A" and sample_allele2 == "T"
					gt_iupac = "W"
				elsif sample_allele1 == "C" and sample_allele2 == "A"
					gt_iupac = "M"
				elsif sample_allele1 == "C" and sample_allele2 == "C"
					gt_iupac = "C"
				elsif sample_allele1 == "C" and sample_allele2 == "G"
					gt_iupac = "S"
				elsif sample_allele1 == "C" and sample_allele2 == "T"
					gt_iupac = "Y"
				elsif sample_allele1 == "G" and sample_allele2 == "A"
					gt_iupac = "R"
				elsif sample_allele1 == "G" and sample_allele2 == "C"
					gt_iupac = "S"
				elsif sample_allele1 == "G" and sample_allele2 == "G"
					gt_iupac = "G"
				elsif sample_allele1 == "G" and sample_allele2 == "T"
					gt_iupac = "K"
				elsif sample_allele1 == "T" and sample_allele2 == "A"
					gt_iupac = "W"
				elsif sample_allele1 == "T" and sample_allele2 == "C"
					gt_iupac = "Y"
				elsif sample_allele1 == "T" and sample_allele2 == "G"
					gt_iupac = "K"
				elsif sample_allele1 == "T" and sample_allele2 == "T"
					gt_iupac = "T"
				elsif sample_allele1 == "N" and sample_allele2 == "N"
					gt_iupac = "N"
				else
					puts "ERROR: Unexpected genotype: #{gt}, recognized as alleles #{sample_allele1} and #{sample_allele2}!"
					exit 1
				end
				seqs[x] << gt_iupac
			else
				puts "ERROR: A genotype (#{gt}) could not be read correctly!"
				puts "  This was found on the following line:"
				puts "  #{l}"
				exit 1
			end
		end
	else
		puts "ERROR: The vcf header could not be read correctly!"
		exit 1
	end
end
puts " done."
STDOUT.flush

# Get the longest id length.
max_id_size = 0
ids.each do |i|
	max_id_size = i.size if i.size > max_id_size
end

# Prepare the Nexus string.
print "Preparing the nexus string..."
nexus_str = "#NEXUS\n"
nexus_str << "\n"
nexus_str << "BEGIN DATA;\n"
nexus_str << "        DIMENSIONS NTAX=#{ids.size} NCHAR=#{seqs[0].size};\n"
nexus_str << "        FORMAT DATATYPE=DNA MISSING=N GAP=- ;\n"
nexus_str << "\n"
nexus_str << "MATRIX\n"
nexus_str << "\n"
ids.size.times do |x|
	nexus_str << "#{ids[x].ljust(max_id_size)}  #{seqs[x]}\n"
end
nexus_str << ";\n"
nexus_str << "END;\n"
puts " done."

# Write the Nexus string to file.
print "Writing the nexus file #{nexus_file_name}..."
nexus_file = File.open(nexus_file_name,"w")
nexus_file.write(nexus_str)
puts " done."
```